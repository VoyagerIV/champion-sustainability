{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useOffsetX = void 0;\nvar _reactNativeReanimated = require(\"react-native-reanimated\");\nvar useOffsetX = function useOffsetX(opts, visibleRanges) {\n  var handlerOffset = opts.handlerOffset,\n    index = opts.index,\n    size = opts.size,\n    loop = opts.loop,\n    dataLength = opts.dataLength,\n    _opts$type = opts.type,\n    type = _opts$type === void 0 ? \"positive\" : _opts$type,\n    _viewCount = opts.viewCount;\n  var ITEM_LENGTH = dataLength;\n  var VALID_LENGTH = ITEM_LENGTH - 1;\n  var TOTAL_WIDTH = size * ITEM_LENGTH;\n  var HALF_WIDTH = 0.5 * size;\n  var viewCount = _viewCount != null ? _viewCount : Math.round((ITEM_LENGTH - 1) / 2);\n  var positiveCount = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n  var startPos = size * index;\n  if (index > positiveCount) startPos = (index - ITEM_LENGTH) * size;\n  var MAX = positiveCount * size;\n  var MIN = -((VALID_LENGTH - positiveCount) * size);\n  var x = (0, _reactNativeReanimated.useDerivedValue)(function () {\n    var _f = function _f() {\n      var _visibleRanges$value = visibleRanges.value,\n        negativeRange = _visibleRanges$value.negativeRange,\n        positiveRange = _visibleRanges$value.positiveRange;\n      if ((index < negativeRange[0] || index > negativeRange[1]) && (index < positiveRange[0] || index > positiveRange[1])) return Number.MAX_SAFE_INTEGER;\n      if (loop) {\n        var inputRange = [-TOTAL_WIDTH, MIN - HALF_WIDTH - startPos - Number.MIN_VALUE, MIN - HALF_WIDTH - startPos, 0, MAX + HALF_WIDTH - startPos, MAX + HALF_WIDTH - startPos + Number.MIN_VALUE, TOTAL_WIDTH];\n        var outputRange = [startPos, MAX + HALF_WIDTH - Number.MIN_VALUE, MIN - HALF_WIDTH, startPos, MAX + HALF_WIDTH, MIN - HALF_WIDTH + Number.MIN_VALUE, startPos];\n        return (0, _reactNativeReanimated.interpolate)(handlerOffset.value, inputRange, outputRange, _reactNativeReanimated.Extrapolate.CLAMP);\n      }\n      return handlerOffset.value + size * index;\n    };\n    _f._closure = {\n      visibleRanges: visibleRanges,\n      index: index,\n      loop: loop,\n      TOTAL_WIDTH: TOTAL_WIDTH,\n      MIN: MIN,\n      HALF_WIDTH: HALF_WIDTH,\n      startPos: startPos,\n      MAX: MAX,\n      interpolate: _reactNativeReanimated.interpolate,\n      handlerOffset: handlerOffset,\n      Extrapolate: {\n        CLAMP: _reactNativeReanimated.Extrapolate.CLAMP\n      },\n      size: size\n    };\n    _f.asString = \"function _f(){const{visibleRanges,index,loop,TOTAL_WIDTH,MIN,HALF_WIDTH,startPos,MAX,interpolate,handlerOffset,Extrapolate,size}=jsThis._closure;{const{negativeRange:negativeRange,positiveRange:positiveRange}=visibleRanges.value;if((index<negativeRange[0]||index>negativeRange[1])&&(index<positiveRange[0]||index>positiveRange[1]))return Number.MAX_SAFE_INTEGER;if(loop){const inputRange=[-TOTAL_WIDTH,MIN-HALF_WIDTH-startPos-Number.MIN_VALUE,MIN-HALF_WIDTH-startPos,0,MAX+HALF_WIDTH-startPos,MAX+HALF_WIDTH-startPos+Number.MIN_VALUE,TOTAL_WIDTH];const outputRange=[startPos,MAX+HALF_WIDTH-Number.MIN_VALUE,MIN-HALF_WIDTH,startPos,MAX+HALF_WIDTH,MIN-HALF_WIDTH+Number.MIN_VALUE,startPos];return interpolate(handlerOffset.value,inputRange,outputRange,Extrapolate.CLAMP);}return handlerOffset.value+size*index;}}\";\n    _f.__workletHash = 3599227485688;\n    _f.__location = \"/Users/zhaodonghao/code/github/react-native-reanimated-carousel/src/hooks/useOffsetX.ts (47:28)\";\n    return _f;\n  }(), [loop, dataLength, viewCount, type, size, visibleRanges]);\n  return x;\n};\nexports.useOffsetX = useOffsetX;","map":{"version":3,"mappings":"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","names":["useOffsetX","opts","visibleRanges","handlerOffset","index","size","loop","dataLength","_opts$type","type","_viewCount","viewCount","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","Math","round","positiveCount","startPos","MAX","MIN","x","value","negativeRange","positiveRange","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","Extrapolate","CLAMP","_f","interpolate"],"sources":["useOffsetX.ts"],"sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport {\n  Extrapolate,\n  interpolate,\n  useDerivedValue,\n} from \"react-native-reanimated\";\n\nimport type { IVisibleRanges } from \"./useVisibleRanges\";\n\nexport interface IOpts {\n  index: number\n  size: number\n  handlerOffset: Animated.SharedValue<number>\n  dataLength: number\n  type?: \"positive\" | \"negative\"\n  viewCount?: number\n  loop?: boolean\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n  const {\n    handlerOffset,\n    index,\n    size,\n    loop,\n    dataLength,\n    type = \"positive\",\n    viewCount: _viewCount,\n  } = opts;\n\n  const ITEM_LENGTH = dataLength;\n  const VALID_LENGTH = ITEM_LENGTH - 1;\n  const TOTAL_WIDTH = size * ITEM_LENGTH;\n  const HALF_WIDTH = 0.5 * size;\n\n  const viewCount = _viewCount ?? Math.round((ITEM_LENGTH - 1) / 2);\n  const positiveCount\n        = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n\n  let startPos = size * index;\n  if (index > positiveCount)\n    startPos = (index - ITEM_LENGTH) * size;\n\n  const MAX = positiveCount * size;\n  const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n  const x = useDerivedValue(() => {\n    const { negativeRange, positiveRange } = visibleRanges.value;\n    if (\n      (index < negativeRange[0] || index > negativeRange[1])\n            && (index < positiveRange[0] || index > positiveRange[1])\n    )\n      return Number.MAX_SAFE_INTEGER;\n\n    if (loop) {\n      const inputRange = [\n        -TOTAL_WIDTH,\n        MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n        MIN - HALF_WIDTH - startPos,\n        0,\n        MAX + HALF_WIDTH - startPos,\n        MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n        TOTAL_WIDTH,\n      ];\n\n      const outputRange = [\n        startPos,\n        MAX + HALF_WIDTH - Number.MIN_VALUE,\n        MIN - HALF_WIDTH,\n        startPos,\n        MAX + HALF_WIDTH,\n        MIN - HALF_WIDTH + Number.MIN_VALUE,\n        startPos,\n      ];\n\n      return interpolate(\n        handlerOffset.value,\n        inputRange,\n        outputRange,\n        Extrapolate.CLAMP,\n      );\n    }\n\n    return handlerOffset.value + size * index;\n  }, [loop, dataLength, viewCount, type, size, visibleRanges]);\n\n  return x;\n};\n"]},"metadata":{},"sourceType":"script"}